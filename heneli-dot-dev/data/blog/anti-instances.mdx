---
title: 'Anti-Instances in Haskell (Draft)'
date: '2023-08-01'
lastmod: '2023-08-01'
version: '0.1'
tags: ['haskell', 'typeclasses', 'short-read']
draft: false
summary: 'Anti-instances with Unsatisfiable.'
images: []
authors: ['default']
layout: PostLayout
audience: ['Haskell: Beginner']
---

<TOCInline toc={props.toc} toHeading={3} asDisclosure />

import {Note} from './components/Note.tsx'

<Note type='info'>
<u>**Prerequisites**</u>: You should be familiar with using basic typeclasses. If not, check out Serokell's [*Introduction to Haskell Typeclasses*](https://serokell.io/blog/haskell-typeclasses) or the _Typeclasses and Instances_ section from Kowainik's [*Strategic Deriving*](https://kowainik.github.io/posts/deriving#typeclasses-and-instances).
</Note>

Typeclass instances are a powerful tool for specifying which overloaded operations are allowed on which types. But what about specifying which operations are _disallowed_ on which types? With the arrival of `Unsatisfiable` in [GHC 9.8.1](https://www.haskell.org/ghc/blog/2023-07-27-ghc-9.8.1-alpha1-released.html), Haskell has better answers now than ever before.

## Anti-Instances: Past and Present

An anti-instance is the intentional rejection of a possible typeclass instance. Anti-instances can either be implicitly defined by omission or explicitly defined by custom type error.

### Omitted Instances

The easiest and most common method for dissallowing typeclass operations on a given type is to simply not provide it a typeclass instance.

For example, there is no `Monoid` instance provided for [`Data.Semigroup.First`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Semigroup.html#t:First). `First` does come with a `Semigroup` instance as appending `First` values obeys the associativity law[^1].

<caption className="flex justify-center text-base">Fig 1: Combining by returning whatever is first</caption>
```hs:ghci
λ> First 99 <> First 12 <> First 30 <> First 7
First 99
λ> ((First 12 <> First 30) <> First 7) <> First 99
First 12
λ> First 12 <> (First 30 <> (First 7 <> First 99))
First 12
```

`First` cannot have a lawful `Monoid` instance as it cannot satisfy the identity law[^1]. This means no value can be supplied to `First` that, when combined a distinct second value, would result in the second value.

Typeclass heirarchies[^2] are often created to distinguish different typeclasses by the laws they require. This makes them an easy place to discover intentionally omitted instances. [*Counterexamples of Type Classes*](https://blog.functorial.com/posts/2015-12-06-Counterexamples.html) covers several intentionally omitted instances in the Purescript language and has a lot of overlap with Haskell.

### Using `TypeError`

The 2016 release of GHC 8.0.1 introduced [`TypeError`](https://downloads.haskell.org/ghc/9.0.1/docs/html/users_guide/exts/type_errors.html) for custom compile-time errors. Unlike with omitted instances, `TypeError` enables explicit anti-instances:

```hs
{-# LANGUAGE GHC2021, DataKinds #-}

import GHC.TypeError (TypeError, ErrorMessage (Text))

class ReflexiveEq a where
    reflexiveEq :: a -> a -> Bool

instance TypeError
  (Text "Equality is not reflexive on Double: Nan /= NaN")
  => ReflexiveEq Double where
    reflexiveEq _ _ = False
```

Triggering a compilation error with the above anti-instance can be seen below:

```hs:ghci
λ> reflexiveEq (1 :: Double) (1 :: Double)

<interactive>:30:1: error: [GHC-64725]
    • Equality is not reflexive on Double: Nan /= NaN
    • In the expression: reflexiveEq (1 :: Double) (1 :: Double)
```

Custom type errors enable user-defined error messages and provide static pointers for adding documentation, displaying with IDE tool tips, and referencing in discussions.

One downside of `TypeError` is its implementation as a type family (AKA a type-level function). This provides flexibility, but also requires greater type-level sophistication from users.

While `TypeError` usage has been minor within the Haskell ecosystem, there are examples of them being used in very cool ways.[^3]

### Introducing `Unsatisfiable`

The upcoming GHC 9.8.1 release will bring an improved version of `TypeError` called `Unsatisfiable`.

```hs
{-# LANGUAGE GHC2021, DataKinds #-}

import GHC.TypeError (Unsatisfiable, ErrorMessage (Text))

instance Unsatisfiable
  (Text "Halt! Functions cannot be compared for equality.")
  => Eq (a -> b)
```

Triggering a compilation error with the above anti-instance can be seen below:

```hs:ghci
λ> (\x -> x) == (\y -> y)

<interactive>:18:11: error: [GHC-22250]
    • Halt! Functions cannot be compared for equality.
    • In the expression: (\ x -> x) == (\ y -> y)
```

Anti-instances defined with `Unsatisfiable` look nearly identical to those defined with `TypeError`, but have some additional benefits.

Unlike `TypeError`, `Unsatisfiable` is a typeclass and thus has kind `Constraint`.

```hs:ghci
λ> :kind TypeError
TypeError :: ErrorMessage -> b
λ> :kind Unsatisfiable
Unsatisfiable :: ErrorMessage -> Constraint
```

This results in more predictable error reporting and fixes buggy behavior seen when `-fdefer-type-errors` is used with `TypeError`.

Most important/prominent/ to users is in they will better match expectations with regards to compile-time behavior and provided greater convience. // TODO - Flesh out

You can find more details and advantages in the [`Unsatisfiable` GHC Proposal](https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0433-unsatisfiable.rst).

## Tips & Tricks

### Escape Hatch

What if you _really need_ an operation from an outlawed instance? Whether facing an implicit anti-instance by omission or an explicit anti-instance by custom type error, the solution is to use a newtype.

Newtypes overcome anti-instances by creating a wrapper type on which fresh instances can be created without polluting the underlying type.

```hs
{-# OPTIONS_GHC -fno-warn-orphans #-}
{-# LANGUAGE GHC2021, DataKinds #-}

import Data.Semigroup (First)
import GHC.TypeError (Unsatisfiable, ErrorMessage (Text))

instance Unsatisfiable (Text "First lacks an identity element")
   => Monoid (First a)

-- | `First`, but with a `Monoid` instance
newtype UnsafeFirst a = UnsafeFirst
  { getUnsafeFirst :: First a }
  deriving (Show, Semigroup)

instance Monoid (UnsafeFirst a) where
  mempty :: UnsafeFirst a
  mempty = error "certified law breaker"
```

This "works":

```hs:ghci
λ> UnsafeFirst (First 1) <> UnsafeFirst (First 3)
UnsafeFirst {getUnsafeFirst = First {getFirst = 1}}
λ> UnsafeFirst (First 1) <> mempty
UnsafeFirst {getUnsafeFirst = First {getFirst = 1}}
```

...at least until there's a law-breaking `mempty` in the first position.

```hs:ghci
λ> mempty <> UnsafeFirst (First 3)
UnsafeFirst {getUnsafeFirst = First
  {getFirst = *** Exception: certified law breaker
CallStack (from HasCallStack):
  error, called at <interactive>:52:12 in interactive:Ghci7
```

Clearly the above example is a bad idea. Carefully consider whether intentional anti-instances. likely that your case also has a better way to achieve your goals.

For example, a different `First` datatype exists in `Data.Monoid` and is implemented as a newtype wrapper over `Maybe`. Combining values under `Data.Semigroup.First` means taking the first value, while combining values under `Data.Monoid.First` means taking the first non-`Nothing` value.

### Verified Counterexamples

One of the best parts of Haskell is how it makes being explicit ergonomic.[^4] Rather than implicitly omitting instances, Haskellers can communicate intent with anti-instances. We can go beyond just providing an explanatory compilation error message and incorporate machine-checked proof into our documentation.

Using property-based testing with [doctests](https://serokell.io/blog/doctests-in-haskell), we can pair laws and get them directly in our documentation to show typeclass instances that are law-abiding or anti-instances which are intentionally law-breaking.

Statically verified counter examples!

![Anti-instance Doctest](/static/images/blog/anti-instance-doctest.png)

<caption className="flex justify-center text-base">Fig 2: Haddocks for Doctested Anti-Instance ([code](https://gist.github.com/hkailahi/ccad605dcf79daf426305e58b4d92359))[^5]</caption>

## Tradeoffs

Compile-time?? Pretty simple, we're not deriving anything so prob not?

What if you disagree with an upstream provided anti-instance? Marginally less annoying than but prob still similar issues as with disagreeing with an exisiting instance. Should controversial anti-instances be orphaned off in separate modules? Coherence is a blessing and curse. Unless you know what you're doing, don't do weird stuff.

Using a newtype to recover exstinsibility can be an inconvience (but arguably is one worth paying).

I don't recommend `Unsatisfiable` orphans.

TODO - Check if `UndecidableInstances` is needed with `Unsatisfiable` (like with `TypeError`)

## Beyond Anti-Instances

### Deprecated Instances

// TODO - `DEPRECATED` already exists. Figure out what is different after this proposal.

Currently, the `DEPRECATED` pragma can be used issue deprecation warning on modules, functions, data constructors, and type constructors, but not on typeclass instances. The GHC proposal for [Deprecated Instances](https://github.com/int-index/ghc-proposals/blob/int-index/deprecated-instances/proposals/0000-deprecated-instances.rst) to fix that was accepted last week!

```hs:ghci
instance {-# DEPRECATED "Do not use NFData (a -> b). See deepseq issue #16" #-}
         NFData (a -> b)
  where
    rnf = rwhnf
```

This provides a path for creating a deprecation period to precede breaking changes.
* Coherence conditions notorious breaking changes (frequency? or just more painful?)

Breaking changes can be preceded with a deprecation period when the problematic code triggers a warning.

* [Deprecated instances PR]https://github.com/ghc-proposals/ghc-proposals/pull/575
* [Opaleye’s API breakage policy](http://h2.jaguarpaw.co.uk/posts/opaleyes-api-breakage-policy/)
* https://github.com/haskell/deepseq/issues/16#issuecomment-1405288710
* https://github.com/haskell/deepseq/issues/16#issuecomment-1405321124
* https://discourse.haskell.org/t/ghc-medium-term-priorities/5600/21?u=angerman

### Custom Type Warnings

A pending proposal for [Custom Type Warnings](https://github.com/adamgundry/ghc-proposals/blob/custom-type-warnings/proposals/0000-custom-type-warnings.rst)

- A `Warning` class, similar to `Unsatisfiable`, (or type family similar to `TypeError`) that presents...
- GHC 9.8.1 also brings the addition of [`WARNING` pragmas with categories](https://github.com/adamgundry/ghc-proposals/blob/warning-pragmas/proposals/0000-warning-pragmas-with-categories.rst). // Flesh out - combining with Custom Type Warnings

### Going Further (Advanced)

Wish List

Indulge with me in some sloppily speculation:
Indulge me with some sloppily speculation:

Type-families that conditionally evaluate to `Unsatisfiable`? For families (or shared categories) of anti-instances? Anti-instance families? Or can you do the same with `Unsatisfiable` superclasses?

Deriving anti-instances?

I'll leave these for further exploration.

## Further Reading

For more on this topic, I highly recommend reading the [`Unsatisfiable` GHC Proposal](https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0433-unsatisfiable.rst) and [*A story told by Type Errors*](https://chshersh.com/type-errors).

Additionally:

*
  <details>

  <summary>For learners looking to level up their typeclass knowledge...</summary>

  For advance beginner and intermediate Haskellers looking for a deeper background on typeclasses and type-level techniques, check out [*Thinking With Types*](https://thinkingwithtypes.com) for comprehensive tour. Other resources I've found useful include:
    * [Code Reuse in PureScript: Fns, Classes, and Interpreters](https://youtu.be/GlUcCPmH8wI) (video)
    * [*An introduction to typeclass metaprogramming*](https://lexi-lambda.github.io/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/)
    * [Coherence of Type Class Resolution](https://youtu.be/bmHd0MoCIiM) (video)
    * [All You Wanted to Know About Type Classes](https://youtu.be/8o51sA12VfI) (video)

  </details>
*
  <details>

  <summary>For intermediate Haskellers and explorers...</summary>

  For those with further interest in this area:
  * See related GHC proposals, the accepted proposal for [Deprecated Instances](https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0575-deprecated-instances.rst) and pending proposal for [Custom Type Warnings](https://github.com/adamgundry/ghc-proposals/blob/custom-type-warnings/proposals/0000-custom-type-warnings.rst).
  * For why typeclass laws require manual verification, see this [StackOverflow answer](https://stackoverflow.com/questions/63523145/why-do-haskells-typeclass-laws-have-to-be-verified-manually). See the [*Verifying replicated data types*](https://dl.acm.org/doi/10.1145/3428284) and [*Quotient Haskell*](https://www.cs.nott.ac.uk/~pszgmh/quotient-haskell.pdf) papers for examples using Liquid Haskell to statically verify typeclass laws and encode laws directly onto datatypes, respectively.

  </details>

## Footnotes

[^1]:
    Associativity and Identity can be defined as follows:

    * Associativity Law: An operation is associative if it's. Types with operations obeying the associative law can be given a [`Semigroup`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Semigroup.html#t:Semigroup) instance.
    * Identity Law: An operation has a neutral element, or [identity](https://en.wikipedia.org/wiki/Identity_element). Types with an identity value and an operation obeying the associative law can be given a `Monoid` instance.

    <div className="overflow-x-auto">
      <table>
        <thead>
          <tr>
            <th scope="col">Property</th>
            <th scope="col">Counterexample</th>
            <th scope="col">Example</th>
          </tr>
        </thead>
        <tbody>
        <tr>
            <th scope="row" className="align-middle">
              <p>Associative:</p>
              <p>`(A <> B) <> C == A <> (B <> C)`</p>
            </th>
            <td className="align-middle">
              ```hs
              newtype Midpoint = Midpoint Double
                deriving (Eq, Show)

              -- Bad! Law-breaking instance!
              instance Semigroup Midpoint where
                (<>) (Midpoint a) (Midpoint b) =
                  Midpoint ((a + b) / 2)

              λ> (Midpoint 1 <> Midpoint 2) <> Midpoint 3
              Midpoint 2.25
              λ> Midpoint 1 <> (Midpoint 2 <> Midpoint 3)
              Midpoint 1.75
              ```
              <caption className="flex justify-center prose prose-sm dark:prose-dark">Left-to-right evaluation is different from right-to-left</caption>
            </td>
            <td className="align-middle">[`Max`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Semigroup.html#t:Max), [`Min`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Semigroup.html#t:Min), [`First`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Semigroup.html#t:First), [`Last`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Semigroup.html#t:Last), [`NonEmpty`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty)</td>
          </tr>
          <tr>
            <th scope="row" className="align-middle">
              <p>Identity:</p>
              <p>`Left Identity: e <> A == A`</p>
              <p>`Right Identity: A <> e == A`</p>
            </th>
            <td className="align-middle">
              ```hs
              -- Bad! Law-breaking instance!
              instance Monoid (NonEmpty a) where
                mempty = undefined

              λ> (10 :| [20, 30]) <> mempty :: NonEmpty Int
              10 :| [20,30]
              λ> mempty <> (10 :| [20, 30]) :: NonEmpty Int
              *** Exception: Prelude.undefined
              CallStack (from HasCallStack):
                undefined, called at...
              ```
              <caption className="flex justify-center prose prose-sm dark:prose-dark">No "empty" value to serve as an identity element</caption>
            </td>
            <td className="align-middle">[`Sum`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Monoid.html#t:Sum), [`Product`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Monoid.html#t:Product), [`All`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Monoid.html#t:All), [`Any`](https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Monoid.html#t:Any)</td>
          </tr>
        </tbody>
      </table>
    </div>

[^2]:
    Some classic typeclass heirarchy examples:
    * [Typeclassopedia](https://wiki.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf)
    * [A Brief Guide to A Few Algebraic Structures](https://argumatronic.com/posts/2019-06-21-algebra-cheatsheet.html)
    * [A guide to the PureScript numeric hierarchy](https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/) (Purescript)
    * [Numhask](https://hackage.haskell.org/package/numhask-0.11.0.2/docs/NumHask.html#g:2) (Alternative numeric hierarchy for Haskell)

[^3]:
    `TypeError` has powered wild things like:
    * [`mezzo`](https://github.com/DimaSamoz/mezzo/tree/master) for type-safe (Western) music composition   [enforcing the rules of counterpoint](https://github.com/DimaSamoz/mezzo/blob/master/src/Mezzo/Model/Errors.  hs)
    * [`silica`](https://github.com/evertedsphere/silica) for more accessible optics with high-quality type   errors.
    https://twitter.com/evertedsphere/status/975660017738309632

[^4]:
    You can read more about the benefits of being explicit in my [Fearless Tinkering is Functional] blog series, including the forthcoming installment - [Fearless Tinkering in Haskell].

[^5]:
    For good reason, testing against something like `monoidLaws` in [`quickcheck-classes`](https://hackage.haskell.org/package/quickcheck-classes) or [`hedgehog-classes`](https://hackage.haskell.org/package/hedgehog-classes) won't work because there's no typeclass instance for providing operations to assert against (again, this is a good thing). However, we can pass implementation as a record/value instead of through a typeclass to do achieve this.

    (lightly-modified html to fit on page)

    Two interesting things to explore would be a) making law-checking without a valid instance more ergonomic and b) a fancier anti-instance wrapper that takes a type-level proof of violation as input and returns an `Unsatisfiable` constraint.
