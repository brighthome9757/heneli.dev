---
title: 'Fearless Tinkering is Functional'
date: '2023-04-05'
lastmod: '2023-04-05'
version: '0.1'
tags: ['functional', 'complexity', 'algebra', 'haskell', 'nixos', 'verse', 'unison']
draft: false
summary: 'A fearless tinkerer sails a ship where entire classes of leakage are rendered an impossibility.'
images: [ ]
authors: ['default']
---

<TOCInline toc={props.toc} toHeading={3} asDisclosure />

ü™ù

Sometimes functional programming gets a bad rap. Critics from industry cite a laundry list of issues: lack of commercial validation, high barrier of entry, sparse library catalog, poor documentation, unfamiliar academic culture, frictious tooling, and a dismal entry-level job market. Advocates counter with [a](https://discord.com/blog/how-discord-scaled-elixir-to-5-000-000-concurrent-users) [number](https://mercury.com/) [of](https://www.pagerduty.com/blog/tag/elixir/) [success](https://www.janestreet.com/) [stories](https://hasura.io/) and appeals pointing to [ongoing](https://elixir-lang.org/blog/2022/10/05/my-future-with-elixir-set-theoretic-types/) [improvements](https://haskell.foundation/projects/). ‚Äú[Things](https://zero-to-nix.com/) [_really_](https://zaid-ajaj.github.io/the-elmish-book/#/) [_are_](https://github.com/haskell/haskell-language-server) [getting](https://www.amazon.com/Production-Haskell-Succeeding-Industry/dp/B0BTNVFR2N) [better](https://github.com/haskell/error-messages)!‚Äù Deserved or otherwise, skepticism is hard to overcome.

It‚Äôs certainly never been the case that a functional language was the de facto industry standard like all of Java, Python, and JavaScript have been. By choice[^1] or by fate, the benefits born of iterating a language independent of widespread reliance have been traded against predictable costs on functional ecosystems. When there‚Äôs 10,000 new programmers learning an imperative language to every individual learning a functional one, can a functional approach really compete?[^2]

My answer is yes. While I see merit in the above critiques, I don‚Äôt believe that any of them are inherent. In fact, I‚Äôll argue that the functional paradigm already has best-in-class learnability thanks to **fearless tinkering**.[^4]

## Fearless in Theory

---

### Fear and Complexity

There‚Äôs an endless list of things that invoke fear in programmers. Buggy software, rolling upgrades, concurrency, bit rot, year-out deadlines, service alerts, tech debt, stale builds, nondeterminism, time libraries, ambiguous requirements, hardware faults, software rewrites, network partitions, scope creep, security, and on and on. Each of these can be terrifying on their own. To make matters worse, software rarely has just a single source of horror. Very simple programs written by very thoughtful programmers can host a multitude.

Without the right tools, conquering these fears can feel impossible. If your tools can‚Äôt protect you, you won‚Äôt be able to protect yourself. Some adopt a defensive programming style, but institutionalizing apprehension isn't an end in itself. What use is an infinite roll of duct tape when a ship takes water? If tape can‚Äôt solve the first leak, should one patch the next, pick their battles, or accept fate and lose hope in the voyage? Does a decision even matter when the ship is already sinking? Maybe swimming to shore and joining a new boat would suffice‚Ä¶ at least until that crew wants to tape their leaks. By then, that too will be someone else‚Äôs problem. The cognitive burden of faulty software is real and difficult to remedy. Programming is a social exercise, and teams will burn out accomodating learned helplessness.

Most fears boil down to uncertainty about **complexity**. As Fred Brooks explained in [No Silver Bullet](https://en.wikipedia.org/wiki/No_Silver_Bullet), there exists **essential complexity** that cannot be avoided and **accidental complexity** that can.[^5] [Out of the Tar Pit](https://github.com/papers-we-love/papers-we-love/blob/2eb8d21/design/out-of-the-tar-pit.pdf) followed up by diagnosing **state**, **control flow**, and **code volume** as the most frequent culprits underlying accidental complexity. The nature of complexity is festering and exponential, so tackling root causes is always better than addressing symptoms. Put another way, preventing leaks by addressing the inherent structural deficiencies of a ship‚Äôs build is favorable to being skilled at plugging holes.

**Fearless tinkering** is the ability to engage a domain and confidently reason about it while unencumbered by accidental complexity. Whether the domain is concurrency, software upgrades, or something else, a fearless tinkerer can rely on the structural guarantees of their context to safely explore their domain and target the essential complexity of the task at hand. A fearless tinkerer sails a ship where entire classes of leakage are rendered an impossibility. What kinds of leaks are prevented? How are they decided? As discussed in the following sections, these guarantees are determined by the algebra of one‚Äôs program.

### On Functional Programming

Here is a collection of commonly discussed characteristics[^6] from functional languages:[^7]
* Referential Transparency.
* Pure functions.
* Declarative.
* Immutability.
* First-Class Functions.
* Higher-Order Functions.
* Expression-Oriented.
* Pattern Matching.
* Tail Call Elimination.
* Managed Effects.
* Algebraic Datatypes.
* Composability.
* Recursive Datatypes.
* Equational Reasoning.

Functional programming doesn‚Äôt solve complexity, but helps one meet it by surfacing its roots. To do this, functional languages deliver several of the more successful and battle-tested approaches to the state, control flow, and volume.

Functional languages _<u>make stateful complexity explicit</u>_. By pairing immutable defaults with performant and easy-to-use APIs, functional languages minimize the need for mutable state. Introducing mutable state thus becomes an intentional and visible action. Given the elimination of destructive updates, compilers are empowered to reward programmers with greater [expressiveness](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29) and [safety](https://en.wikipedia.org/wiki/Software_transactional_memory) at less cost. Some functional languages make explicit their ‚Äúeffects‚Äù with types, creating a distinction that allows separate reasoning of  ‚Äúeffect-free‚Äù and ‚Äúeffectful‚Äù code.

With a greater reliance on _<u>declarative constructs</u>_ (expressions) over _<u>imperative ones</u>_ (statements), functional languages eliminate a number of control flow complexities. Jump-based statements, which break compositionality and equational reasoning, are replaced with expressions that can be substituted for their evaluations. Bigger programs can be faithfully decomposed into smaller ones. This allows for the local reasoning of individual parts to hold up when global reasoning is needed about the whole. Thanks to the sole determination of a function‚Äôs outputs on its inputs, purely functional programming creates an experience where ‚Äúwhat you see is what you get‚Äù.

Functional languages address program volume by making mechanical the act of _<u>stripping programs down to their essence</u>_. For instance, verbose wrangling code can be collapsed into neat reusable patterns using higher-order functions and composition. Typed functional languages use various polymorphisms to expand infinitely-many functions over one domain into an economy of functions over infinite domains. Typed functional languages also reduce cognitive volume by offloading the rote calculations of dynamism onto programmer‚Äôs better-suited counterparts in computers. As elaborated in the following section, relegating implementation details to the relevant semantic layer makes declarative APIs is naturally terse. Judiscious use of abstraction capabilities assists in uncovering rock-solid, lean foundations for APIs and wider ecosystems.

Armed with the properties of functional languages, programmers can reclaim their cognitive sovereignty and fearlessly explore software in action.

### Ideas over Implementation Details

> Declare it. Answer how with what. Break the causal chain and unshackle from the past. The world is simply what you say it is. 
> - a sage functional programmer, probably

If language is a tool for thought, then one should value dialects enabling the natural communication of them. Blunted alternatives that intersperse anything meaningful with robotic recitations of language internals or error-prone adaptations to outside alterations are painful to tolerate. A language that yields such fragile mental models debilitates a programmer‚Äôs ability to handle real-world scenarios like context-switching, requirements evolution, and the eventuality of a system‚Äôs growth beyond what can be kept in one‚Äôs head. The essential complexity programmers face is already challenging enough.

When the business calls for an algorithm to determine how many users visited their website last week, no one‚Äôs first thought should have to be about for-loops, heap allocations, b-tree indexes, logic gates, or cosmic rays. No, an API that‚Äôs better suited to immediate communication might yield something like:

```java
all_users -> filter_by(visited_since(-7 days)) -> count()
```

Declarative programming simplifies the act of learning because it 1) meets one at their layer of abstraction and 2) let‚Äôs one focus solely on what‚Äôs in front of them. A well-designed declarative API lays out all the vocabulary and structure one should need, such that formulating solutions through sentences is as natural as placing blocks in a game of Tetris. Learners can focus on encoding the logic of the place they actually care about instead of the windy road they may have taken to get there. By only necessitating a specification of ‚Äòwhat is‚Äô, the programmer is unburdened by the interconnected history of their model‚Äôs state transitions.

### Constraints Liberate

> Freedom at one level leads to restriction at another. A constraint at one level leads to freedom and power at another level.
> - R√∫nar Bjarnason, [Constraints liberate, Liberties constrain](https://youtu.be/GqmsQeSzMdw)

Observing the underlying properties of a program is the key to unlocking its simplification. A simple pure function is simple because of the numerous constraints that have already been imposed on it. Also, the restriction of mapping input sets onto output sets eases the discovery of additional relationships in one‚Äôs program. Employing popular [functional](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/) [techniques](https://kowainik.github.io/posts/haskell-mini-patterns) to prune superfluous code paths can make invariants lurking in our programs even more apparent. By building a toolkit of common operations with associated constraints, one can unlock a useful arsenal of powers to call upon in various programming situations.

One could rightly object that having to learn new mathematical abstractions is trading one kind of complexity for another. In practice, there are but a small handful of core abstractions that programmers will typically run into and are thus worth their collective weight.[^8] Learning these abstractions could also be viewed as deepening one's understanding of their domain. The major benefit of learning an abstraction is that once you‚Äôve understood it, you‚Äôve understood it for all of its applications.

<div className="overflow-x-auto">
  <table>
    <thead>
      <tr>
        <th scope="col">Property</th>
        <th scope="col">Disallows</th>
        <th scope="col">Power</th>
        <th scope="col">Example</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">Functional Purity</th>
        <td>
          ```jsx chrome=no
          logInfo(msg):
              upload_ssn() 
              return ‚Äúinfo:‚Äù + msg
          ```
        </td>
        <td>Fearlessly execute, reproduce, and cache </td>
        <td>Haskell</td>
      </tr>
      <tr>
        <th scope="row">Immutable</th>
        <td>
          ```jsx chrome=no
          f(x):
            global += x
            return global
          ```
        </td>
        <td>Fearlessly rollback and share dependencies</td>
        <td>Nix</td>
      </tr>
      <tr>
        <th scope="row" >
          <p>Associative:</p>
          <p>`(A <> B) <> C == A <> (B <> C)`</p>
          </th>
        <td>
          ```jsx chrome=no
          >>> try_simultaneously(
            deposit($200),
            withdraw($100),
            withdraw($150)
          )
          >>> print_bank_report()
          Transaction Log: +200, -150, -100, -25 (overdraw fee)
          Current Balance: -$75
          >>
          ```
        </td>
        <td>Fearlessly parallelize</td>
        <td>MapReduce</td>
      </tr>
      <tr>
        <th scope="row" >
          <p>Commutative:</p>
          <p>`A <> B == B <> A`</p>
          </th>
        <td>
          ```jsx chrome=no
          for x in xs:
              if f(x):
                  break
              if g(x):
                  continue
              counter++
          ```
        </td>
        <td>Fearlessly reorder executions</td>
        <td>Pijul</td>
      </tr>
      <tr>
        <th scope="row" >
          <p>Transitive:</p>
          <p>`F: A -> B, G: B -> C` => `G . F: A -> C`</p>
          </th>
        <td>
          ```jsx chrome=no
          neg_to_null(x: int) -> Optional[int]:
              if x < 0: return None
              else: return x

          double_it(a: int) -> int:
              return a * a

          >>> double_it(neg_to_null(-10))
          *** error!
          ```
        </td>
        <td>Fearlessly compose</td>
        <td>`GHC.Generics`, Profunctor Optics</td>
      </tr>
      <tr>
        <th scope="row" >
          <p>Join-Semilattice:</p>
          <p>`Associative: (A <> B) <> C == A <> (B <> C)`</p>
          <p>`Commutative: A <> B == B <> A`</p>
          <p>`Idempotent: A <> A == A`</p>
          </th>
        <td>
          ```jsx chrome=no
          f(edits):
              for edit in edits:
                  x.async_append(edit)

          >>> f([‚ÄòHello‚Äô, ‚ÄòWorld‚Äô])
          >>> get_x()
          [‚ÄòInit‚Äô, ‚ÄòWorld‚Äô, ‚ÄòHello‚Äô]
          ```
        </td>
        <td>Fearlessly synchronize</td>
        <td>CRDTs</td>
      </tr>
      <tr>
        <th scope="row" >Denumerable</th>
        <td>
          ```jsx chrome=no
          is_odd(x: int) -> bool:
              if x == 0: False
              if x == 1: True
              if x == 2: False
              if x == 17: True

          >>> is_odd(10000)
          *** error!
          ```
        </td>
        <td>Fearlessly pattern match</td>
        <td>Error-Handling in Rust</td>
      </tr>
    </tbody>
    <caption>Figure 1: A small sampling of properties and the powers they grant.</caption>
  </table>
</div>

## Fearless in Practice

---

> Beyond the right tool for the job, it is the right values for the job‚Ä¶ and then the right software for the values.
> - Bryan Cantrill, [Platform as a Reflection of Values](https://vimeo.com/230142234)


Programmers make mistakes. As such, our tools should aspire not to punish us for unfamiliarity or occasional incorrectness. Too often users stumble into a tool's legitimate accidental complexity, only to be chided for ‚Äúholding it wrong‚Äù as if they should feel guilty for letting the tool paint them into a corner. Of course, this doesn‚Äôt mean anyone wants overzealous tools that ‚Äúhelpfully‚Äù enact what hasn‚Äôt been asked for. Instead, tools should focus on preventing unrecoverable choices from being made too casually or too late. When a situation calls for an action with serious implications, our tools should help us feel the weight of our request. Uniformly weighting every possibility will lead users to assume that either every action is reasonable or every action is fallible. Tools shouldn‚Äôt be afraid to immediately inform us when they think we‚Äôre wrong. Discovering mistakes during the construction of a new home is much less painful than making the same discoveries after a family has moved into it. Selecting tools by their structural guarantees is about using our values to elect the ways our software _can‚Äôt_ go wrong. A fearless tinkerer can be wrong, strong!

In this section, I‚Äôll introduce two functional technologies and illustrate how their structural properties enable **fearless tinkering**. These alone won‚Äôt do functional ecosystems justice as there are too many examples for exhaustive and in-depth coverage.[^9] Even amongst the tools I‚Äôll mention, there are other dimensions of assurance that I won‚Äôt get to. Conversely, I also won't cover the structural deficiencies and unnecessary footguns[^10] they hold stymieing further fearlessness.

Much more important than any specific technology are the ideas that underlie them. Demonstrating a market for fearless approaches to the critical pain points of our daily work will help future iterations of our technologies and their alternatives make accessible the required structural guarantees.


### Nix & NixOS

The entropy of modern software is staggering. Programs inside programs directing separate programs exist, and each of them contains their own digital metropolis. Whether it‚Äôs the shear connectors in the bridges, building codes of the plumbing networks, or newest floor plan atop a towering skyscraper, every software artifact reflects a choice made by someone somewhere. The feats of modern software could not be made if every virtual wheel needed reinventing. A global and communal project of shared decisions is harnessed to base, tweak, and publish new constructions.

Despite how foundational accessing external developments is, interfacing with outside software remains a tremendous challenge. Every piece of software has its own installation manual and distribution strategy. Attaining pre-built infrastructure or the materials to create one‚Äôs own means traversing complicated and intersecting digital supply chains. Brittle runbooks, non-reproducible scripts, and imperative packaging tools that freely step on each other‚Äôs work lead to uniquely broken and divergent systems. Fundamental issues like build-time variability, unspecified dependencies, and implicit mutatation of shared libraries can turn one-off upgrades into intractable archeological treasure hunts. When stuck in dependency hell, a teammate voicing that some software ‚Äúworks on their machine‚Äù offers more dread than helpfulness.

Nix attempts to solve these problems by introducing a purely functional DevOps ecosystem. By representing all software components in an immutable graph, Nix is able to offer rich queries about one‚Äôs system and defang previously panic-inducing deployments. With a declarative language for reproducible system configurations, installing software simply becomes writing a Nix expression to describe a target system with that package installed. The same is true for applying parameter configurations, upgrades, uninstallations, or any deployment action. Developers and operators can focus on what they want their system to look like instead of spending their time divining a sequential migration path to get there. The quality-of-life gains from the structural guarantees Nix provides are highlighted below via ‚Äòfearless environments‚Äô and ‚Äòfearless sharing‚Äô.

#### Fearless Environments

> The <u>world</u> is all that is the case. A <u>computation</u> is any action taken by a programmable device. An <u>environment</u> is the set of all past and present worlds that a computation can observe. An <u>effect</u> is a computation that depends on or changes the program‚Äôs environment. We run programs to produce effects in the world around us.
> - Patrick Thomson, definitions from ["Building Haskell Programs with Fused Effects"](https://youtu.be/vfDazZfxlNs?t=145)


#### Fearless Sharing

### Haskell

Fixing a bug? No problem!

Need a new feature? Sure thing!

Did you read about that best practice? Incorporation was easy!

Handle another edge case? Say less!

Upgrading 50 libraries? üíØ

#### Fearless Refactoring

It is straightforward and mechanical to translate functions into ‚Äúgeneralized‚Äù forms. For example, one progression could be:
* function with several **hardcoded arguments**
* function on **several arguments**
* function on a **record of arguments** (configuration record)
* function on a **record of functions** computing arguments ([handle pattern](https://jaspervdj.be/posts/2018-03-08-handle-pattern.html))
* function dispatched to an ad-hoc **interpreter translating polymorphic functions into  concrete functions** computing arguments (final encoding, [finally tagless](https://youtu.be/JxC1ExlLjgw))
* function, defined with an eDSL, dispatched to an **interpreter translating an AST into functions** computing arguments (initial encoding, [defunctionalization](https://blog.sigplan.org/2019/12/30/defunctionalization-everybody-does-it-nobody-talks-about-it/))
* ‚Ä¶and back again (refunctionalization)

Programmers can pick whatever individual or combination of these equivalent forms best suit their task.


#### Fearless Maintenance

### Functional Adjacent

## A Fearless Future 
---

### Fearless Interoperability with Verse

### Fearless DX with Unison

## Wrap

Thanks for reaching the end! Here are some options if you‚Äôd like to get started with functional programming:
* If you‚Äôd like an entry point into application programming with functional languages, I recommend checking out [Elm](https://elm-lang.org/) and [Elixir](https://elixir-lang.org/). 
* If you‚Äôre interested in a functional devops experience, I recommend checking out [Nix](https://nixos.org/).[^11]
* If you are looking for a follow-up on incorporating algebraic foundations into your daily work, I recommend reading [Algebra-Driven Design](https://algebradriven.design/).
* If you want to fully immerse yourself in functional programming without familiar imperative crutches, I recommend checking out [Haskell](https://www.haskell.org/).[^12]

[^1]:
    The prelude to the [Haskell Foundation Whitepaper](https://haskell.foundation/whitepaper/) has good coverage on the previous success of the ‚ÄúAvoid success at all costs‚Äù slogan and current evolution beyond the phrase.

[^2]: 
    Source: I made it up. The best I could find was the [2022 Stack Overflow Developer Survey](https://survey.stackoverflow.co/2022/#technology) and the [March 2023 TIOBE index](https://www.tiobe.com/tiobe-index/), which can‚Äôt directly validate my claim but weakly support it‚Äôs order of magnitude.

    Per Stack Overflow, Scala (2.59%), Haskell (2.22%), Elixir (2.15%), Clojure (1.51%), F# (1.03%), Erlang (0.9%), and OCaml (0.59%) make up a combined 10.4% of 71,547 responses for [Most Popular Technologies](https://survey.stackoverflow.co/2022/#technology-most-popular-technologies) survey, none of which meet the 5000 connection minimum in the 69,362 respondent [Work With vs Want to Work With](https://survey.stackoverflow.co/2022/#worked-with-vs-want-to-work-with-language-worked-want) survey. 

    Per TIOBE popularity index, only #25 F# (0.53%), #31 Haskell (0.34%), and #38 Scala (0.23%) make the top 50, with all of Elixir, Erlang, Common Lisp, Schema, Clojure, F#, Erlang, and OCaml landing between top 51 - 100.

[^4]: // TODO

[^5]: The definition of accidental complexity in 'Out of the Tar Pit' is more specific to requirements of the user, but. in this post, can be treated more broadly as meaning self-inflicted or avoidable complexity.

[^6]: Overlapping, non-compulsory, non-exhaustive

[^7]: 
    You probably noticed that I cowardly deferred to others the task of formally defining ‚Äúfunctional programming‚Äù. The fact of matter is that FP is a vibe.

    More seriously, I use ‚Äúfunctional programming‚Äù as shorthand for a style that avoids mutation and implicit ‚Äúeffects‚Äù. I also define ‚Äúfunctional languages‚Äù as those enabling the representation of programs with expressions that can be substituted for their evaluated value (as is the case for even [‚Äúimpure‚Äù eDSLs like `State` or `IO`](https://twitter.com/lexi_lambda/status/1242878496076189702?s=20)).

    Both the usefulness and accuracy of the term ‚Äúfunctional‚Äù has been debated. Even the meaning and relation of commonly associated descriptors like ‚Äúdeclarative‚Äù is contested. There doesn‚Äôt seem to be a minimal feature set (not even higher-order functions!) across languages that are widely considered functional. The heuristic for determining which languages are functional might as well be whether the language mentions ‚Äòfunctional‚Äô in its marketing material or shares a family origin with those listed on the sidebar of r/functionalprogramming.

    For the sake of this post, I am willing to tolerate the imprecision of ‚ÄòFearless Tinkering is Functional‚Äô over something that might better match like ‚Äòexpression-oriented‚Äô, ‚Äòdenotative‚Äô, ‚Äòalgebraic‚Äô, or 'structural' (definitional claims are unfalsifiable anyways). I am also willing, when a claim reflects my own opinions, to forgo small nuances (or bury them in footnotes) when speaking to unacquainted audiences. My goals with this specific post are more about connecting valuable ideas through familiar phrasing to a wider audience than advancing a discussion for those already equipped with understanding. 

    I do think there are more general problems with various commonly-used terms by functional programmers, and that particular statements often lead to poor intuitions and mismatched discussions. I hope to publish more on this topic soon.

[^8]:
    No one needs to learn category theory to become a [great functional programmer](http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/)! Sure, some people have brought great ideas from category theory and other mathematical fields back to the realm of programming. But math gets invented to incorporate great ideas originating from programming (and everywhere else) as well. The [streelight effect](https://en.wikipedia.org/wiki/Streetlight_effect) goes both ways! Programmers should treat math as a tool that serves to give us understanding, rather than a tool we serve to give our understanding.

[^9]:
    For example, I don't cover fearless concurrency in Erlang and Elixir. If you have a follow-up covering something, [I'd love to link it below](https://github.com/hkailahi/heneli.dev/issues):
    
    * tbd

[^10]:
    Like any other programming language, the functional ones aren't free of warts and confusing conventions from oral tradition. For example, see https://nix.dev/anti-patterns/ and https://github.com/NorfairKing/haskell-WAT.
    
    So fearless...
    ```haskell
    Prelude> length ('a','b')
    1
    Prelude> maximum (2,1)
    1
    Prelude> minimum (1,2)
    2
    Prelude> sum (2,1)
    1
    Prelude> and (False, True)
    True
    Prelude> or (True, False)
    False
    ```

[^11]: 
    For video learners, Brian McKenna's [RootConf 2019 talk](https://youtu.be/RtqWE5lgaCg) and Burke Libbey's [Nix: What Even is it Though](https://youtu.be/6iVXaqUfHi4) are accessible overviews of Nix and it's ideas.

    To get started using Nix, I recommend following the [Zero to Nix](https://zero-to-nix.com/) Quick Start guide. From there, I recommend checking out nix.dev, Official NixOS learning page, and/or the follow-up resources recommended at the end of the [Zero to Nix](https://zero-to-nix.com/start/learn-more) Quick Start guide.

    Some blogposts that I've particularly enjoyed include:
    * [Erase your darlings](https://grahamc.com/blog/erase-your-darlings/)
    * [Paranoid NixOS Setup](https://xeiaso.net/blog/paranoid-nixos-2021-07-18) and [Paranoid NixOS on AWS](https://xeiaso.net/blog/paranoid-nixos-aws-2021-08-11)
    * [Tidying up your $HOME with Nix](https://juliu.is/tidying-your-home-with-nix/)
    * [Declarative management of dotfiles with Nix and Home Manager](https://www.bekk.christmas/post/2021/16/dotfiles-with-nix-and-home-manager)
    * [Managing Firefox on macOS with Nix](https://cmacr.ae/post/2020-05-09-managing-firefox-on-macos-with-nix/)

    For intermediate audiences, check out the upcoming [NixOS in Production](https://leanpub.com/nixos-in-production) book.

[^12]:
    [14] For video learners, Philipp Hagenlocher's [Haskell for Imperative Programmers](https://www.youtube.com/playlist?list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV) playlist is a phenomenal introductory exposure. If, like me, you like 1000+ page tutorials with ample hand-holding, you could learn with [Haskell from First Principles](https://haskellbook.com/). Otherwise, the upcoming [Effective Haskell](https://pragprog.com/titles/rshaskell/effective-haskell/) book seems, from my brief skim, like a promising early resource. Additionally, helpful online references like [Typeclasses](https://typeclasses.com/) and [Kowainik‚Äôs blog](https://kowainik.github.io/posts) can be very beginner-friendly. [fp-course](https://github.com/system-f/fp-course) and Brian McKenna's [video walkthrough](https://www.youtube.com/playlist?list=PLly9WMAVMrayYo2c-1E_rIRwBXG_FbLBW) is a great hands-on exercise that‚Äôs perfect for beginners struggling to grapple with fundamental abstractions. Finally, [What I Wish I Knew When Learning Haskell](https://github.com/sdiehl/wiwinwlh) can serve as a solid, free reference for checking your understanding of various topics.

    For intermediate audiences, I can strongly recommend [Production Haskell](https://www.amazon.com/Production-Haskell-Succeeding-Industry/dp/B0BTNVFR2N), [Thinking with Types](https://thinkingwithtypes.com/), and the _Concurrent_ section of the classic [Parallel and Concurrent Programming in Haskell](https://www.amazon.com/Parallel-Concurrent-Programming-Haskell-Multithreaded/dp/1449335942). Additionally, promising works on the horizon like [The Haskell Optimization Handbook](https://github.com/input-output-hk/hs-opt-handbook.github.io) and some unannounced efforts make now a great time to get in.