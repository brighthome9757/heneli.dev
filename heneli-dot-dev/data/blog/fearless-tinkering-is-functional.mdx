---
title: 'Fearless Tinkering is Functional (Draft)'
date: '2023-04-26'
lastmod: '2023-04-26'
version: '0.1'
tags: ['functional', 'complexity', 'algebra', 'haskell', 'nix', 'verse', 'unison']
draft: false
summary: 'A fearless tinkerer sails a ship where entire classes of leakage are rendered an impossibility.'
images: []
authors: ['default']
layout: PostSimple
---

<TOCInline toc={props.toc} toHeading={3} asDisclosure />

ü™ù

Sometimes functional programming gets a bad rap. Critics from industry cite a laundry list of issues including lack of commercial validation, high barrier of entry, sparse library catalog, poor documentation, unfamiliar academic culture, frictious tooling, and a dismal entry-level job market. Advocates counter [with](https://blog.janestreet.com/why-ocaml/) [a](https://discord.com/blog/how-discord-scaled-elixir-to-5-000-000-concurrent-users) [number](https://blog.replit.com/nix) [of](https://hasura.io/blog/from-zero-to-hipster-haskell-in-production-97ea99d90c3b/) [success](https://www.pagerduty.com/blog/tag/elixir/) [stories](https://mercury.com/) and appeals pointing [to](https://elixir-lang.org/blog/2022/10/05/my-future-with-elixir-set-theoretic-types/) [ongoing](https://blog.janestreet.com/oxidizing-ocaml-locality/) [improvements](https://haskell.foundation/projects/). ‚Äú[Things](https://www.amazon.com/Production-Haskell-Succeeding-Industry/dp/B0BTNVFR2N) _[really](https://zero-to-nix.com/) [are](https://pijul.org/posts/2023-05-23-nest-a-new-hope/)_ [getting](https://zaid-ajaj.github.io/the-elmish-book/#/) [better](https://leanpub.com/fp-made-easier)!‚Äù Deserved or otherwise, skepticism is hard to overcome.

It‚Äôs certainly never been the case that a functional language was the de facto industry standard like all of Java, Python, and JavaScript have been. By choice[^1] or by fate, the benefits born of iterating a language independent of widespread reliance have been traded against predictable costs on functional ecosystems. When there‚Äôs 10,000 new programmers learning an imperative language to every individual learning a functional one, can a functional approach really compete?[^2]

My answer is yes. While the above critiques have merit, I don‚Äôt believe that any of them are inherent. In fact, I‚Äôll argue that the functional paradigm already has best-in-class learnability thanks to **fearless tinkering**.[^4]

## Fearless in Theory

---

### Fear and Complexity

There‚Äôs an endless list of things that invoke fear in programmers:
<div className="overflow-x-auto">
  |  |  |  |   |
  | - | :- | -: | :-: |
  | Buggy software | rolling upgrades | concurrency | bit rot |
  | year-out deadlines | service alerts | tech debt | stale builds |
  | nondeterminism | clocks | ambiguous requirements | hardware faults |
  | software rewrites | network partitions | scope creep | security |
</div>
...and on and on. Each of these can be terrifying on their own. To make matters worse, software rarely contains just a single source of horror. Very simple programs written by very thoughtful programmers can host a multitude.

Without the right tools, conquering these fears can feel impossible. If your tools can‚Äôt be trusted, your contributions can't be either. Some adopt a defensive programming style, but institutionalizing apprehension isn't an end in itself. What use is an infinite roll of duct tape when a ship takes water? If tape can‚Äôt solve the first leak, should one patch the next, pick their battles, or accept fate and lose hope in the voyage? Does a decision even matter when the ship is already sinking? Maybe swimming to shore and joining a new boat would suffice‚Ä¶ at least until that crew wants to tape their leaks. By then, that too will be someone else‚Äôs problem. The cognitive burden of faulty software is real and difficult to remedy. Programming is a social exercise, and teams will burn out accommodating learned helplessness.

Most fears boil down to uncertainty about **complexity**. As Fred Brooks explained in [No Silver Bullet](https://en.wikipedia.org/wiki/No_Silver_Bullet), there exists **essential complexity** that cannot be avoided and **accidental complexity** that can.[^5] [Out of the Tar Pit](https://github.com/papers-we-love/papers-we-love/blob/2eb8d21/design/out-of-the-tar-pit.pdf) followed up by diagnosing **state**, **control flow**, and **code volume** as the most frequent culprits underlying accidental complexity. The nature of complexity is festering and exponential, so tackling root causes is always better than addressing symptoms. Put another way, preventing leaks by addressing the inherent structural deficiencies of a ship‚Äôs build is favorable to being skilled at plugging holes.

**Fearless tinkering** is the ability to engage a domain and confidently reason about it while unencumbered by accidental complexity. Whether the domain is concurrency, software upgrades, or something else, a fearless tinkerer can rely on the structural guarantees of their context to safely explore their domain and target the essential complexity of the task at hand. A fearless tinkerer sails a ship where entire classes of leakage are rendered an impossibility. What kinds of leaks are prevented? How are they decided? As discussed in the following sections, these guarantees are determined by the algebra of one‚Äôs program.

### On Functional Programming

The functional style encourages transformation-based workflows over state-based workflows. To motivate this approach, functional languages commonly offer a collection[^6] of characteristics:[^7]
<div className="overflow-x-auto">
  |  |  |  |   |
  | - | :- | -: | :-: |
  | Referential Transparency | Pure functions | Declarative | Immutability |
  | First-Class Functions | Higher-Order Functions | Expression-Oriented | Pattern Matching |
  | Tail Call Elimination | Managed Effects | Algebraic Datatypes | Compositionality |
  | Recursive Datatypes | Equational Reasoning | | |
</div>

Functional programming doesn‚Äôt solve complexity, but helps one meet it by surfacing its roots. To do this, functional languages deliver several of the more successful and battle-tested approaches to the state, control flow, and volume.

Functional languages _<u>make stateful complexity explicit</u>_. By pairing immutable defaults with performant and easy-to-use APIs, functional languages minimize the need for mutable state. Introducing mutable state thus becomes an intentional and visible action. Given the elimination of destructive updates, compilers are empowered to reward programmers with greater [expressiveness](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29) and [safety](https://en.wikipedia.org/wiki/Software_transactional_memory) at less cost. Some functional languages make explicit their ‚Äúeffects‚Äù with types, creating a distinction that allows separate reasoning of ‚Äúeffect-free‚Äù and ‚Äúeffectful‚Äù code.

With a greater reliance on _<u>declarative constructs</u>_ (expressions) over _<u>imperative ones</u>_ (statements), functional languages eliminate a number of control flow complexities. Jump-based statements, which break compositionality, are replaced with expressions that can be substituted for their evaluations. Bigger programs can be faithfully decomposed into smaller ones. This allows local reasoning on individual parts to hold up when global reasoning is needed about the whole. Thanks to the sole determination of a function‚Äôs outputs on its inputs, purely functional programming creates an experience where ‚Äúwhat you see is what you get‚Äù.

Functional languages address program volume by _<u>making decomposition mechanical</u>_. Programs and their domains can be stripped programs down to their essence. For instance, verbose wrangling code can be collapsed into neat reusable patterns using higher-order functions and composition. Typed functional languages use various polymorphisms to replace infinitely-many functions over one domain with an economy of functions over infinite domains. Typed functional languages also reduce cognitive volume by offloading the rote calculations of dynamism onto programmer‚Äôs better-suited counterparts in computers. As elaborated in the following section, relegating implementation details to the relevant semantic layer makes declarative APIs naturally terse. Judiscious use of abstraction capabilities assists in uncovering rock-solid, lean foundations for APIs and wider ecosystems.

Armed with the properties of functional languages, programmers can reclaim their cognitive sovereignty and fearlessly explore software in action.

### Ideas over Implementation Details

> Declare it. Answer how with what. Break the causal chain and unshackle from the past. The world is simply what you say it is.
>
> - a sage functional programmer, probably

If language is a tool for thought, then one should value dialects enabling the natural communication of them. Blunted alternatives that intersperse anything meaningful with robotic recitations of language internals or error-prone adaptations to outside alterations are frustrating to tolerate. A language that yields such fragile mental models debilitates a programmer‚Äôs ability to handle real-world scenarios like context-switching, requirements evolution, and the eventuality of a system‚Äôs growth beyond what can be kept in one‚Äôs head. The essential complexity programmers face is already challenging enough.

When the business calls for an algorithm to determine how many users visited their website last week, no one‚Äôs first thought should have to be about for-loops, heap allocations, hash indexes, logic gates, or cosmic rays. No, an API that‚Äôs better suited to immediate communication might yield something like:

```jsx
all_users -> filter_by(visited_since(-7 days)) -> count()
```

Declarative programming simplifies the act of learning because it 1) meets one at their layer of abstraction and 2) let‚Äôs one focus solely on what‚Äôs in front of them. A well-designed declarative API lays out all the vocabulary and structure one should need, such that formulating solutions through sentences is as natural as placing blocks in a game of Tetris. Learners can focus on describing the place they actually care about instead of the windy road taken to get there. By only necessitating specification of a goal state, the programmer are unburdened by the interconnected history of their model's state transitions.

### Constraints Liberate

> Freedom at one level leads to restriction at another. A constraint at one level leads to freedom and power at another level.
>
> - R√∫nar Bjarnason @ Scala World 2015, [Constraints liberate, Liberties constrain](https://youtu.be/GqmsQeSzMdw)

Observing the underlying properties of a program is the key to unlocking its simplification. Pure functions are simple because of the numerous constraints imposed on them. The restriction of mapping input sets onto output sets eases the discovery of additional relationships in one‚Äôs program. Employing popular [functional](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/) [techniques](https://kowainik.github.io/posts/haskell-mini-patterns#phantom-type-parameters) to prune superfluous code paths can make further invariants lurking in our programs even more apparent. By building an arsenal of common operations with associated constraints, one can unlock a useful toolkit of powers to call upon in various programming situations.

One could rightly object that having to learn new mathematical abstractions is trading one kind of complexity for another. In practice, there are but a small handful of core abstractions that programmers will typically run into and are thus worth their collective weight.[^8] Learning frequently occuring abstractions is useful for formalizing one's understanding of the domains they characterize. The major benefit of learning said abstractions is that once you‚Äôve understood them, you‚Äôve understood them for all of their applications.

<div className="overflow-x-auto">
  <table>
    <thead>
      <tr>
        <th scope="col">Property</th>
        <th scope="col">Disallows</th>
        <th scope="col">Power</th>
        <th scope="col">Example</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">Functional Purity</th>
        <td>
          ```jsx chrome=no
          log4Info(msg):
              upload_ssn()
              return ‚Äúinfo: ‚Äù + msg
          ```
        </td>
        <td>Fearlessly execute, reproduce, and cache</td>
        <td>Haskell</td>
      </tr>
      <tr>
        <th scope="row">Immutable</th>
        <td>
          ```jsx chrome=no
          f(x):
            global += x
            return global
          ```
        </td>
        <td>Fearlessly rollback and share dependencies</td>
        <td>Nix</td>
      </tr>
      <tr>
        <th scope="row">
          <p>Associative:</p>
          <p>`(A <> B) <> C == A <> (B <> C)`</p>
        </th>
        <td>
          ```jsx chrome=no
          >>> average(1, average(2, 3))
          1.75
          >>> average(average(1, 2), 3)
          2.25
          ```
        </td>
        <td>Fearlessly parallelize</td>
        <td>MapReduce</td>
      </tr>
      <tr>
        <th scope="row">
          <p>Commutative:</p>
          <p>`A <> B == B <> A`</p>
        </th>
        <td>
          ```jsx chrome=no
          >>> wells_fargo.make_transations([
            deposit($200),
            withdraw($100),
            withdraw($100)
          ])
          >>> wells_fargo.show_activity()
          Transaction Log:
            -100, -25 (overdraw fee),
            +200,
            -100, -25 (overdraw fee)
          Current Balance: -$50
          ```
        </td>
        <td>Fearlessly reorder executions</td>
        <td>Pijul</td>
      </tr>
      <tr>
        <th scope="row" >
          <p>Transitive:</p>
          <p>`F: A -> B`, <br/> `G: B -> C` <br/> => `G . F: A -> C`</p>
        </th>
        <td>
          ```jsx chrome=no
          neg_to_null(x: int) -> Optional[int]:
              if x < 0: return None
              else: return x

          square(a: int) -> int:
              return a * a

          >>> square(neg_to_null(-10))
          *** error!
          ```
        </td>
        <td>Fearlessly compose and delegate</td>
        <td>`GHC.Generics`, Profunctor Optics</td>
      </tr>
      <tr>
        <th scope="row" >
          <p>Join-Semilattice:</p>
          <p>`Associative: (A <> B) <> C == A <> (B <> C)`</p>
          <p>`Commutative: A <> B == B <> A`</p>
          <p>`Idempotent: A <> A == A`</p>
        </th>
        <td>
          ```jsx chrome=no
          f(edits):
              for edit in edits:
                  x.async_append(edit)

          >>> f([‚ÄòHello‚Äô, ‚ÄòWorld‚Äô])
          >>> get_x()
          [‚ÄòInit‚Äô, ‚ÄòWorld‚Äô, ‚ÄòHello‚Äô]
          ```
        </td>
        <td>Fearlessly update and collaborate</td>
        <td>Electric SQL</td>
      </tr>
      <tr>
        <th scope="row" >Denumerable</th>
        <td>
          ```jsx chrome=no
          is_odd(x: int) -> bool:
              if x == 0: False
              if x == 1: True
              if x == 2: False
              if x == 17: True

          >>> is_odd(10000)
          *** error!
          ```
        </td>
        <td>Fearlessly pattern match</td>
        <td>Error-Handling in Rust</td>
      </tr>
    </tbody>
    <caption>Figure 1: A small sampling of properties and the powers they grant.</caption>

  </table>
</div>

## Fearless in Practice

---

> Beyond the right tool for the job, it is the right values for the job‚Ä¶ and then the right software for the values.
>
> - Bryan Cantrill @ Node Summit 2017, [Platform as a Reflection of Values](https://vimeo.com/230142234)

Programmers make mistakes. As such, our tools should aspire not to punish us for unfamiliarity or occasional incorrectness. Too often users stumble into a tool's legitimate accidental complexity, only to be chided for ‚Äúholding it wrong‚Äù as if they should feel guilty for letting the tool paint them into a corner. Of course, tools that overreact to surface considerations can be just a problematic. No one wants an overzealous tool that ‚Äúhelpfully‚Äù enacts what hasn‚Äôt been asked for. Instead, tools should focus on preventing unrecoverable choices from being made too casually or too late. When a situation calls for an action with serious implications, our tools should help us feel the weight of our request. Uniformly weighting every possibility will mislead users into thining that every action is reasonable or every action is fallible. Tools shouldn‚Äôt be afraid to immediately report suspected incorrectness. Discovering mistakes during the construction of a new home is much less painful than making the same discoveries after a family has moved into it.

Approaches that meet each critique with an independent solution are prone to local maxima. Breakthroughs often require recognition of the systemic complexities underpinning individual occurrences. Ideal tools are dedicated to proactively sussing out fundamental weakness, rather than reactively catering to symptoms.[^9] Hence, selecting tools by their **structural guarantees** is about using one's **values** to elect the ways in which their software _can‚Äôt_ go wrong. A fearless tinkerer knows they can be wrong, strong!

In this section, I‚Äôll introduce two functional technologies and illustrate how their structural properties enable **fearless tinkering**. These alone won‚Äôt do functional ecosystems justice.[^10] Even amongst the tools mentioned, there are plenty of assurances I won't cover. Conversely, I won't spend much time on their structural deficiencies and vestigial footguns[^11]. Much more important than any specific technology are the ideas that underlie them. Calling out the need for fearless approaches to the pain points of daily work will help future technologies incorporate the relevant structural guarantees.


### Nix & NixOS

The entropy of modern software is staggering. Programs inside programs directing separate programs exist, with each layer containing its own digital metropolis. Whether it be the shear connectors in the bridges, building codes of the plumbing networks, or newest floor plan atop a towering skyscraper, every software artifact reflects a choice made by someone somewhere. The feats of modern software could not be made if every virtual wheel needed reinventing. A global and communal project of shared decisions is harnessed to base, tweak, and publish new constructions.

Despite how foundational accessing external developments is, interfacing with outside software remains a tremendous challenge. Every piece of software has its own installation manual and distribution strategy. Attaining pre-built infrastructure or the materials to create one‚Äôs own means traversing complicated and intersecting digital supply chains. Brittle runbooks, non-reproducible scripts, and imperative packaging tools that freely step on each other‚Äôs work lead to uniquely broken and divergent systems. Fundamental issues like build-time variability, unspecified dependencies, and implicit mutation of shared libraries can turn one-off upgrades into intractable archeological treasure hunts. When stuck in dependency hell, a teammate voicing that some software ‚Äúworks on their machine‚Äù offers more dread than helpfulness.

Nix attempts to solve these problems by introducing a purely functional DevOps ecosystem. By representing all software components in an immutable graph, Nix is able to offer rich queries about one‚Äôs system and defang panic-inducing deployments. With a declarative language for reproducible system configurations, installing software simply becomes the act of writing a Nix expression that describes a target system with that package installed. The same is true for applying parameter configurations, upgrades, uninstallations, patches, or any deployment action. Instead of divining sequential migration paths, developers and operators can focus solely on what they want their system to look like. The evolution of traditional infrastructure is contrasted with Nix below.

#### Road to Reproducibility

For many developers, infrastructure is an uncomfortable area. Whether it‚Äôs the state of a cluster on `us-east-2` or a configuration outside one‚Äôs project repository, reasoning about [action at a distance](https://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29) can be treacherous. Further, the stakes are often high when managing software deployments. A tangled web of mutual, implicit dependencies means that modifying one‚Äôs system could lead to getting stuck in an invalid state. Tolerating a ‚Äúworking‚Äù yet unsatisfactory environment is frequently preferable to the risks of transitioning to something better. As experimentation with alternatives is difficult, iterating is normally restricted to when one‚Äôs hand is forced or the alternative has already been intimately understood. Even the modern practice of automated upgrades for existing dependencies is [fraught](https://arxiv.org/abs/2109.11921v1). Tools for managing remote environments tend to remain unfamiliar as the consequences of trying them out might yield an expensive `$CLOUD_PROVIDER` bill.

A horrible culmination of these frictions is regularly found in operational firefighting. Operators are tasked with debugging a live system whose interface, tools, and symptoms are typically only practiced against when problems occur. Even in organizations with significant platform investments, the exploratory surface of test deployments rarely reflects the time and space pollution built up across all contributing local developer and remote production environments.

Application programming, in contrast, can give developers a sense of power and ease. Assuming a stable working environment, the behavior and outputs of a local program are far more observable. Equipped with a test harness, REPL, and breakpointing facilities, an interactive view of one‚Äôs program, including local bindings and available operations, can be explored. An application programmer can wield static analyzers, linters, IDE feedback, and all their most familiar tools to iteratively coax their programs into the desired shape. The ultimate execution of their developments in production can be separated behind various stages of evaluation like continuous integration, peer review, staging deployments, and quality assurance.

The extent to which work is disposable is the extent to which work is safe to do. While it might mean tremendous pain in the short term, application programmers can usually throw their hands up and start over from scratch when an insurmountable problem arises locally. If a developer ties their local project repository into an knot, they can blow it away and pull down a fresh copy. During development, application programmers regularly break their domain in ways that would be intolerable anywhere else. Though program behaviors are inseparable from their execution environments, application programmers can approximate control over their state space by optimizing for their own fixed environment.

Is it possible to bring the same advantages from application programming to the world of infrastructure? _Containers_ and _Infrastructure as Code_ are popular answers, but these are not without limitations. For instance, the same issues of imperativity that existed before containers still exist inside of them today. While containers and microVMs provide [varying degrees of isolation](https://fly.io/blog/sandboxing-and-workload-isolation/), "contained" environments don't inherently ensure compositionality or reproduciblity. As Matthew Croughan put it, "Docker is repeatable, but not reproducible." One can define instructions, but executing them doesn't guarantee the same output. As such, a `Dockerfile` in version control can only nominally correspond to an image stored in a container registry. Containers partially address configuration drift when using the same image, but don't offer guarantees about iterating a new image or even rebuilding the same one. The mutability of common base images pushes users onto shifting grounds and creates a host of compliance concerns. Worse, the already limited means by which associated tools like vulnerability scanners determine an image's origin and dependencies are [easily obfuscated](https://youtu.be/9weGi0csBZM). Likewise, IaC offerings that market themselves as "immutable infrastructure" without reproducibility guarantees leave a lot on the table. These create a non-uniform experience as environments are delivered declaratively yet developed imperatively. Masking a leaky abstraction with a 'declarative' interface (obscures resulting pathologies and) will, of course, not be "fearless" and underdeliver in terms of simplicity and use cases.

Meanwhile, Nix has developed to fill these gaps. Nix can fit neatly within existing infrastructure, letting engineers recover [reproduciblity and its benefits](https://reproducible-builds.org/) while using [IaC](https://nix.dev/tutorials/nixos/build-and-deploy/deploying-nixos-using-terraform), [containers](https://floxdev.com/blog/flox-and-containers), and other solutions. Nix can also subsume various existing tools with things like NixOS, Home-Manager, NixOps, and deploy-rs. This versatility allows Nix to be introduced piecemeal into projects and organizations.

#### Nix: A Minimal Primer

In the Nix language, everything is an expression. This includes Nix's central data structure, the [derivation](https://zero-to-nix.com/concepts/derivations). Derivations can be thought of as recipes for building software components. These build plans include stable references to the build plans of their direct dependencies.  A key part of making Nix "purely functional" is the separation of evaluation and execution. Building a software component with Nix consists of the following steps:

1. _Instantiation_ - evaluation of nix expression that assembles a derivation
2. _Realisation_ - execution of derivation instructions and addition of output into the Nix Store

The Nix Store is an append-only graph database that stores components in the host's file system (typically under `/nix/store`). Every package, service, and configuration is stored in an immutable way, meaning it cannot be modified after being created. Instead, changes result in new component versions, leaving the previous ones intact.

The location of a package in the Nix Store is determined by the hash of its derivation. As a derivation contains references to its exact inputs, Nix is able to ensure that a given package is built in the same way every time. This property is referred to as being "input-addressable", and is how Nix works by default. For example, a `foo` package stored at `/nix/store/9fjirpbq4yhzbf89hdkg9plk65mjazxy-foo-package` will have been created by a derivation whose contents hash to `9fjirpbq4yhzbf89hdkg9plk65mjazxy`. Any change to a transitive dependency of `foo` will be reflected by a new hash for `foo`'s new derivation (ex. `/nix/store/3wby0ym34x4rb5vv78vh58f4p2pvw19j-foo-package`).

The Nix literature defines ["correct deployments"](https://books.google.ca/books?id=gP2kAAAACAAJ) as software deployments that "given identical inputs... should behave the same on an end-user machine as on the developer machine". This is a useful albeit weaker notion of reproducibility than [bit-for-bit reproducibility](https://reproducible-builds.org/docs/definition/). While Nix can ensure the build plans are executed with the same steps and inputs, it can't ensure a determinstic binary output as the underlying package being built might require usage of bespoke, non-determinstic tools.

Rather than storing components by the hash of their build plan, Nix support is progressing for storing components by the hash of their build outputs. This property is commonly referred to as being **content-addressable**, and would reduce recompilation via [_early cutoff_](https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf). For obvious reasons, bit-for-bit reproducibility is important for content-addressable builds.

#### Fearless Environments

> The <u>world</u> is all that is the case. A <u>computation</u> is any action taken by a programmable device. An <u>environment</u> is the set of all past and present worlds that a computation can observe. An <u>effect</u> is a computation that depends on or changes the program‚Äôs environment. We run programs to produce effects in the world around us.
>
> - Patrick Thomson @  Strange Loop 2019, definitions from ["Building Haskell Programs with Fused Effects"](https://youtu.be/vfDazZfxlNs?t=145)

Nix allows us to define reproducible and composable environments.

Whether it's installing a new package or upgrading your system, changes through Nix are made atomically. This means all changes happen at once or not at all, ensuring users are never left in a partially updated state even if an operation is interrupted. If an upgrade causes issues, one can immediately roll back to the previous configuration. As a result, iteration doesn't need to be a high-commitment activity. Users can
tryout packages with temporary installations that don't pollute their environments. Binaries used in one-off commands don't have live beyond their usage. The combination of rollbacks and version control let's one recreate their enviroment from any point in the past. If one doesn't need something anymore, they can get rid of it without fear of it being unrecoverable. package hoarding is rendered unnecessary and configurations are able to be minimal.

As each package is stored in a unique path, different versions or variants of a package can coexist without conflict.

Nix ensures a transactional semantics: builds can always safely be interrupted, restarted, or run in parallel.

Cross compiling


#### Fearless Sharing

> When you share code with the world, how are they supposed to build it? Are they sure that they are running the same code that you, the author and builder, intended for them to run?
>
> As engineers, we would love for all these to be true: I show up in a README, it's one command to build the project, run it, and it's built in the exact same way that the developer intended. There's nothing hidden about the build process and I can see that it's repeatable. This is transparency and this is what open source is all about.
>
> - Julien Urraca @ Open Source 101 2023, ["From Nix to Docker - Everything You Need to Know About Polygot Package Management"](https://youtu.be/onBQhwuPOAc?t=231)



The source deployment model is one in which packages are deployed in source form as opposed to binary form. This allows flexibility in build-time configurations and a greater degree of trust. Binary deployments, on the other hand, require less resources like disk space for the binaries and network resources for obtaining the binary package.

Unfortunately, source deployments can be expensive as resources are required to obtain and store the sources, CPU time and memory to build the package, and disk space for temporary Ô¨Åles and the Ô¨Ånal results. To make matters worse, binary deployment only involves runtime dependencies, while source deployment may involve additional dependencies that are only used at build time, such as compilers

Best of source and binary distribution. Trustworthy binary caches.
- Binary Caching: Even though Nix supports building from source, it also has a binary cache (cache.nixos.org by default) that hosts pre-built binaries. When you install a package, Nix first checks whether the binary is available in the cache. If it is, Nix downloads and installs the binary instead of building from source. This makes package installation faster, which is one of the key advantages of binary distributions.
- Source Availability: Like source distributions, Nix always allows you to build from source. This gives you the flexibility to modify the source code and build the package according to your specific needs.

Sharing both internally and externally. Free dependency sharing. Best of source and binary distributions.

In fact, Nix can recover greater sharing from existing infrastructure like [optimally-layered docker images](https://grahamc.com/blog/nix-and-layered-docker-images/) and third-party dependency management for [Bazel builds](https://nix-bazel.build/).

Input-addressable


All these guarentees work with native file system / environment instead of a bespoke environment. If we want to multiple separate environments, we can do that while and share mutual dependencies without worrying that modifications from one project will break or leak into another.

#### Supplementary Examples

<details>
  <summary>Package Management</summary>

  The preferred method of installing packages with Nix [declaratively with a configuration file](https://github.com/hkailahi/dotnix/blob/c59b2e2654f8a84cab1ac59ab72e991ffe84ca70/home.nix#L20). This can be done at the project-level developer environments or globally within a system configuration file.

  For example, let's say I need to install [`firefox`](https://search.nixos.org/packages?channel=23.05&show=firefox&from=0&size=50&sort=relevance&type=packages&query=firefox) and upgrade my global [`python`](https://search.nixos.org/packages?channel=23.05&show=python311&from=0&size=50&sort=relevance&type=packages&query=python311) installation. Regardless of whether my system is specified with NixOS, Home-Manager, or Nix-Darwin, the corresponding configuration change will look something like:

  ```diff
      environment.systemPackages = with pkgs; [
  -      python310
  +      python311
  +      firefox
      ];
  ```

  You can check out the [system configuration for my 2019 MacBook Pro](https://github.com/hkailahi/dotnix/tree/main) on Github along with [countless others](https://github.com/search?q=dotfiles+language%3ANix&type=repositories&l=Nix).
</details>

<br />

<details>
  <summary>Auditing Packages</summary>

  Let's say I wanted to know the dependencies of my local `python` installation. Outside of garbage collection, any package installed via Nix should be present in one's local Nix database (called the [Nix Store](https://zero-to-nix.com/concepts/nix-store)):
  ```bash
  $ readlink $(which python)
  /nix/store/7fkcip5klr0gksrjgdb3xf0wiz89mdak-python3-3.11.3/bin/python
  ```

  One route would be to inspect the package's build plan (called a [derivation](https://zero-to-nix.com/concepts/derivations)) to find direct dependencies and their build plans:
  ```bash
  $ nix derivation show $(which python) | jq '.[].inputDrvs | keys'
  [
    "/nix/store/1sh46d9v2n87kabvhnsqqpsrn0l8j9qb-readline-8.2p1.drv",
    "/nix/store/3yzr5644didynr33gmg8ps3pd40i5gsk-ncurses-6.4.drv",
    "/nix/store/4k5amvhhn2ahfj4lnwfmhdb3i6fd3pc8-configd-453.19.drv",
    "/nix/store/5l1qsivyqzvwim32c4lqlw08gqkr1pda-libffi-3.4.4.drv",
    "/nix/store/ah5g0p1vca3izf2z72w7xwgi0gwfr2rz-sqlite-3.41.2.drv",
    "/nix/store/anqxwbxv66qwqwnxmrk5dczlzawan3w4-bash-5.2-p15.drv",
    "/nix/store/b05r3wxalqnkhik6d60xxjbizx01vd32-Python-3.11.3.tar.xz.drv",
    "/nix/store/bd9w0gdpl5h8n97yfgv0i6mdwyqz4lv9-xz-5.4.3.drv",
    "/nix/store/dgy0q5xz9h8yphvn72rrpmdsnvhll5d9-gdbm-1.23.drv",
    "/nix/store/dkx3cs1vqvsafsca08vx681d5jhhsr8v-bzip2-1.0.8.drv",
    "/nix/store/j0xw7lx8bxi6098psd1x9qgqq8k3186d-zlib-1.2.13.drv",
    "/nix/store/kw4n89mqr55jzqpw66sncyvpgs3lscyx-libxcrypt-4.4.33.drv",
    "/nix/store/mbqjy5ff44qsw8bzi7b4q07hnhp5nmy5-mailcap-2.1.53.drv",
    "/nix/store/n92l3i5n4a2z3gy7qhvq6545vvrih0cz-stdenv-darwin.drv",
    "/nix/store/nh3pwqzjjsh9ldvimxswsslrs7vw58kb-nuke-references.drv",
    "/nix/store/vhsawk7n84qsb052923kc6mc8rxzg1c8-python-setup-hook.sh.drv",
    "/nix/store/xxwl7wc8pyf66z89w1s3x0h1mbx1kawc-expat-2.5.0.drv",
    "/nix/store/ymxifdj2b2li33jybh29d5c9v79i403v-openssl-3.0.8.drv",
    "/nix/store/zvh05gmr58z8fkjlnchj5vyd81nbvz23-tzdata-2023c.drv"
  ]
  ```

  One could imagine recursively inspecting ancestral build plans to collect transitive dependencies. Instead, I'll use Nix's CLI to query the dependency graph directly and temporarily install `graphviz` to visualize it:
  ```bash
  $ nix-store --query $(which python) --graph | nix-shell --packages graphviz --command 'dot -Tpng > python_deps.png'
  ```
  ![Python Dependency Graph](/static/images/blog/python_deps.png)

  Or I could explore dependencies interactively with the `nix-tree` file browser.
  ```bash
  $ nix-tree $(which python)
  ```
  ![Python Dependency Graph](/static/images/blog/nix_tree_python.png)

  As the entire build specification for my python installation exists in the Nix Store, tools like [vulnix](https://github.com/nix-community/vulnix) can be used to audit it against the NIST National Security Database.
  ```bash
  $ vulnix $(which python)
  5 derivations with active advisories

  ------------------------------------------------------------------------
  flex-2.6.4

  /nix/store/0fjlvx3rfi9p4y8wb723hvz7q0f4ijs7-flex-2.6.4.drv
  CVE                                                CVSSv3
  https://nvd.nist.gov/vuln/detail/CVE-2019-6293     5.5

  ------------------------------------------------------------------------
  # ...
  ```

  We can also generate SBOMs with [`sbomnix`](https://github.com/tiiuae/sbomnix):
  ```bash
  $ sbomnix $(which python) && head sbom.csv
  WARNING  Command line argument '--meta' missing: SBOM will not include license information (see '--help' for more details)
  INFO     Loading runtime dependencies referenced by '/nix/store/blz0ndg2hnph226br17qrqbcj088yqsf-python3-3.10.11/bin/python3.10'
  INFO     Wrote: sbom.cdx.json
  INFO     Wrote: sbom.spdx.json
  INFO     Wrote: sbom.csv
  "name","pname","version","patches","system","out","cpe","purl","urls","store_path"
  "ICU-66108","ICU","66108","","x86_64-darwin","['/nix/store/aas1khljq5sp40ryb578adg4yc0wgjdf-ICU-66108']","cpe:2.3:a:ICU:ICU:66108:*:*:*:*:*:*:*","pkg:nix/ICU@66108","","/nix/store/k6d279xzyqi0fin6408in8yfymqzis5q-ICU-66108.drv"
  "Libsystem-1238.60.2","Libsystem","1238.60.2","","x86_64-darwin","['/nix/store/zg52hvdcbgkiybjn7w1n30l0skxrx08k-Libsystem-1238.60.2']","cpe:2.3:a:Libsystem:Libsystem:1238.60.2:*:*:*:*:*:*:*","pkg:nix/Libsystem@1238.60.2","","/nix/store/xlpi8lsqxb0mv3k34xrziff37andhpy2-Libsystem-1238.60.2.drv"
  "Security-55471.14.18","Security","55471.14.18","","x86_64-darwin","['/nix/store/0d8xnyf5ijrqixg4n90098y5s9lk1cgr-Security-55471.14.18']","cpe:2.3:a:Security:Security:55471.14.18:*:*:*:*:*:*:*","pkg:nix/Security@55471.14.18","","/nix/store/m17yissf06s7f8gnyq37xr64j7d4b888-Security-55471.14.18.drv"
  "bash-5.2-p15","bash-5.2-p15","5.2","/nix/store/a73wzcks7h2y814qxa1z3kv1hg205mpm-bash52-001 /nix/store/xc3h9isl5566i6a4pvdsgin26rchijrq-bash52-002 /nix/store/sxc8xmi7caxaiywzh15za9crpk3bw98z-bash52-003 /nix/store/2ynclzrdl0hy9miy6k8gcwgzw4mhsmd0-bash52-004 /nix/store/z76vsdh69cvwkwhwg69k7d1znwjmx6hf-bash52-005 /nix/store/1fw5..."
  "brotli-1.0.9","brotli","1.0.9","","x86_64-darwin","['/nix/store/m0hh9mxbgvwp0pnvn4s1s7yzzic4kfcm-brotli-1.0.9-lib', '/nix/store/q906v945rq108jcpmfr5xzcgq9g70p4r-brotli-1.0.9']","cpe:2.3:a:brotli:brotli:1.0.9:*:*:*:*:*:*:*","pkg:nix/brotli@1.0.9","","/nix/store/7rd6lx3zkb2xbcy0a54pp9bpix060r1g-brotli-1.0.9.drv"
  "bzip2-1.0.8","bzip2","1.0.8","/nix/store/ws73d521m0im6x7nhb0836i51z2yd9dq-bzip2-1.0.6.2-autoconfiscated.patch","x86_64-darwin","['/nix/store/6ckxm90hlpwhvzkzif384ric3xs3mdjd-bzip2-1.0.8']","cpe:2.3:a:bzip2:bzip2:1.0.8:*:*:*:*:*:*:*","pkg:nix/bzip2@1.0.8","","/nix/store/byvhbgf18yxwnqird6f423wyijd7izq1-bzip2-1.0.8.drv"
  "configd-453.19","configd","453.19","","x86_64-darwin","['/nix/store/84irf9wyg2lfvblq1fr54qp6qqcqh0q1-configd-453.19']","cpe:2.3:a:configd:configd:453.19:*:*:*:*:*:*:*","pkg:nix/configd@453.19","","/nix/store/gbnwmrym9x104b1ywr3asmn12icgzp08-configd-453.19.drv"
  "curl-8.1.1","curl","8.1.1","/nix/store/w1c7ihmg8ykp1ddpjldq7i5407cqsbz4-7.79.1-darwin-no-systemconfiguration.patch","x86_64-darwin","['/nix/store/jlayla89klra9qxlydqbrld8aizp8nf9-curl-8.1.1']","cpe:2.3:a:curl:curl:8.1.1:*:*:*:*:*:*:*","pkg:nix/curl@8.1.1","","/nix/store/d2j52ik1ykyr7v5641j5fp8225j4h6ll-curl-8.1.1.drv"
  "expat-2.5.0","expat","2.5.0","","x86_64-darwin","['/nix/store/jldbmj8wpd81az2zlc6bql9f5cwi5y2b-expat-2.5.0']","cpe:2.3:a:expat:expat:2.5.0:*:*:*:*:*:*:*","pkg:nix/expat@2.5.0","","/nix/store/ld9l8jhgfdhrbqjl8rj9wq3addblwkja-expat-2.5.0.drv"
  ```

</details>

<br />

<details>
  <summary>Working with Containers</summary>

  OCI images can be created and manipulated with the `dockerTools` module provided by `nixpkgs`. Here is [an example](https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-dockerTools) of a simple nix expression for building an image containing the [`hello`](https://www.gnu.org/software/hello/manual/hello.html) binary:

  ```nix
  pkgs.dockerTools.buildImage {
    name = "hello";
    tag = "latest";
    copyToRoot = pkgs.buildEnv {
      name = "image-root";
      paths = [ pkgs.hello ];
      pathsToLink = [ "/bin" ];
    };

    config.Cmd = [ "/bin/hello" ];
  }
  ```

  Further documentation and examples can be found in the [Nixpkgs Manual](https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-dockerTools). For better optimized containers, see [Optimising Docker Layers for Better Caching with Nix](https://grahamc.com/blog/nix-and-layered-docker-images/) and [`nix2container`](https://github.com/nlewo/nix2container).
</details>

### Haskell

> Fixing a bug? No problem!
>
> Need a new feature? Sure thing!
>
> Did you read about that best practice? Incorporation was easy!
>
> Handle another edge case? Say less!
>
> Upgrading 50 libraries? üíØ

Haskell is a general-purpose programming language that's statically-typed, lazy, and purely functional.


As Gabriella Gonzalez noted in the [2016 State of the Haskell Ecosystem](https://github.com/Gabriella439/post-rfc/blob/main/sotu.md#server-side-web-programming), "where Haskell shines in usability is the runtime support for software transactional memory (which differentiates Haskell from Go), lightweight threads that use non-blocking I/O, and garbage collection (which differentiates Haskell from Rust)."[^12]


#### Fearless Refactoring

It is straightforward and mechanical to translate functions into ‚Äúgeneralized‚Äù forms. For example, one progression could be:

- function with several **hardcoded arguments**
- function on **several arguments**
- function on a **record of arguments** (configuration record)
- function on a **record of functions** computing arguments ([handle pattern](https://jaspervdj.be/posts/2018-03-08-handle-pattern.html))
- function, specified with a **type-level DSL**, **interpreted by translating polymorphic functions into concrete functions** computing arguments (final encoding, [finally tagless](https://youtu.be/JxC1ExlLjgw))
- function, defined with a **value-level eDSL**, **interpreted by translating an AST into functions** computing arguments (initial encoding, [defunctionalization](https://blog.sigplan.org/2019/12/30/defunctionalization-everybody-does-it-nobody-talks-about-it/))
- ‚Ä¶and back again (refunctionalization)

Programmers can pick whatever individual or combination of these equivalent forms best suit their task.

#### Fearless Maintenance

#### Supplementary Examples

<details>
  <summary>Deriving Behaviors for Free</summary>

  Like Swift protocols or Rust traits, typeclasses in Haskell let programmers associate types with named sets of operations. This association is done by providing, inheriting, or generating an implementation on a given type.

  For example, let's say I created a `PrimaryColor` type whose values could be `Red`, `Yellow`, or `Blue`. To make `PrimaryColor`s displayable and comparable, I could provide "instances" of the `Show` and `Eq` typeclasses:
  ```hs
  data PrimaryColor = Red | Yellow | Blue

  instance Eq PrimaryColor where
    (==) :: PrimaryColor -> PrimaryColor -> Bool
    Red == Red       = True
    Yellow == Yellow = True
    Blue == Blue     = True
    _ == _           = False

  instance Show PrimaryColor where
    show :: PrimaryColor -> String
    show Red    = "Red"
    show Yellow = "Yellow"
    show Blue   = "Blue"
  ```

  Haskell can generate instances automatically using a typeclasses' default implementations, a type's shape, a type's field instances, or by borrowing instances from an identitically-shaped type.

  ```hs
  data Person = Person
    {  name  :: String
    ,  age   :: Int
    }
    deriving stock (Eq, Ord, Show)
    deriving anyclass (FromJSON, ToJSON, FromCsv, ToCsv, FromDbRow, ToDbRow)
  ```

  The `Eq` instance generated above uses the underlying `Eq` instances on `String` and `Int`. This way two people are equal if and only if they share the same `name` and `age`. In addition to equality, we know at a glance that people can be ordered, displayed, serialized to JSON & CSV, and stored in a database.

  ```hs
  Œª> phil = Person "Phil" 25
  Œª> zoe = Person "Zoe" 42
  Œª> phil > zoe
  False
  Œª> zoe == zoe
  True
  ```
</details>

<br />

<details>
  <summary>Property-Based Testing</summary>

  Property-based Testing originated from Haskell with the QuickCheck library.
</details>

<br />

<details>
  <summary>Concurrency but Headache-Free</summary>

  Software Transactional Memory

  Who knew that the same language known for avoiding shared mutable state could be so good at using shared mutable state?
</details>

### Functional Adjacent

## A Fearless Future

---

### Fearless Interoperability with Verse

### Fearless DX with Unison

## Wrap

Thanks for reaching the end! Here are some options if you‚Äôd like to get started with functional programming:

- If you‚Äôd like an entry point into application programming with functional languages, I recommend checking out [Elm](https://elm-lang.org/) and [Elixir](https://elixir-lang.org/).
- If you‚Äôre interested in a functional devops experience, I recommend checking out [Nix](https://nixos.org/).[^13]
- If you are looking for a follow-up on incorporating algebraic foundations into your daily work, I recommend reading [Algebra-Driven Design](https://algebradriven.design/).
- If you want to fully immerse yourself in functional programming without familiar imperative crutches, I recommend checking out [Haskell](https://www.haskell.org/).[^14]

## Footnotes

[^1]:
    The prelude to the [Haskell Foundation Whitepaper](https://haskell.foundation/whitepaper/) has good coverage on the previous success of the ‚ÄúAvoid success at all costs‚Äù slogan and current evolution beyond the phrase.
[^2]:
    Source: I made it up. The best I could find was the [2022 Stack Overflow Developer Survey](https://survey.stackoverflow.co/2022/#technology) and the [March 2023 TIOBE index](https://www.tiobe.com/tiobe-index/), which can‚Äôt directly validate my claim but weakly support it‚Äôs order of magnitude.

    Per Stack Overflow, Scala (2.59%), Haskell (2.22%), Elixir (2.15%), Clojure (1.51%), F# (1.03%), Erlang (0.9%), and OCaml (0.59%) make up a combined 10.4% of 71,547 responses for [Most Popular Technologies](https://survey.stackoverflow.co/2022/#technology-most-popular-technologies) survey, none of which meet the 5000 connection minimum in the 69,362 respondent [Work With vs Want to Work With](https://survey.stackoverflow.co/2022/#worked-with-vs-want-to-work-with-language-worked-want) survey.

    Per TIOBE popularity index, only #25 F# (0.53%), #31 Haskell (0.34%), and #38 Scala (0.23%) make the top 50, with all of Elixir, Erlang, Common Lisp, Schema, Clojure, F#, Erlang, and OCaml landing between top 51 - 100.
[^4]:
    I suspect that many of my peers will find this claim absurd. It's important to acknowledge that countless have bounced off of functional languages and that serious efforts by functional advocates have been spent because of these approachability issues.

    When I say the functional paradigm has best-in-class *learnability*, my focus is on the inherent qualities of functional languages. One could substitute my use of *learnability* for *understandability*, and that would be a fair starting point. However, that wouldn‚Äôt capture my view that learnability is directly correlated to how far one can explore without consequence. The functional style achieves this freedom by explicating assumptions and enabling the decomposition of concepts. This burdenless discoverability is why I believe the functional paradigm is more learnable (and continually so) for beginner, intermediate, and advanced practitioners. Functional shops should be doing a better job of wielding this market advantage, and yet, bafflingly, many have found ways to turn this strength into a weakness.

    Of course, learning a language in practice has as much to do with the language itself as with its peripherals. Pedagogy, tooling, industrial opportunities, marketing, and community are all essential for initial exposure to ideas and a holistic learning experience. While the peripherals around a paradigm or language can change, the fundamentals are more sticky. The software industry has shown a large appetite for new language variations, but a minimal appetite for new language foundations. While functional languages haven't been popular, they've certainly been influential. A slow yet constant trickle of functional language features appear in mainstream languages as need to overcome accidental complexity remains.

    This all isn‚Äôt to say that functional programming is the ultimate destination. Comparisons to mainstream paradigms is a limited experiment as none of the existing incarnations are particularly ‚Äúlearnable‚Äù. While the functional paradigm can offer greater safeguards than imperative alternatives, neither has yielded a satisfactory and industrial-grade experience embodying other qualities of a [learnable experience](https://web.archive.org/web/20201105061430/http://worrydream.com/LearnableProgramming/) (ex. interactivity, visualization, uniformity, immediacy, etc). It‚Äôs possible that achieving this will require new paradigms built on top of functional foundations. More on that in the future‚Ä¶
[^5]:
    The definition of accidental complexity in 'Out of the Tar Pit' is more specific to requirements of the user, but. In this article, can be treated more broadly as meaning self-inflicted or avoidable complexity.
[^6]: Overlapping, non-compulsory, non-exhaustive
[^7]:
    You may have noticed that I cowardly deferred to others the task of formally defining ‚Äúfunctional programming‚Äù. The fact of matter is that FP is a vibe.

    More seriously, I use ‚Äúfunctional programming‚Äù as shorthand for a style that avoids mutation and implicit ‚Äúeffects‚Äù. I also define ‚Äúfunctional languages‚Äù as those enabling the representation of programs with expressions that can be substituted for their evaluated value (as is the case for even [‚Äúimpure‚Äù eDSLs like `State` or `IO`](https://twitter.com/lexi_lambda/status/1242878496076189702?s=20)).

    Both the usefulness and accuracy of the term ‚Äúfunctional‚Äù has been debated. Even the meaning and relation of commonly associated descriptors like ‚Äúdeclarative‚Äù is contested. There doesn‚Äôt seem to be a minimal feature set (not even higher-order functions!) across languages that are widely considered functional. The heuristic for determining which languages are functional might as well be whether the language mentions ‚Äòfunctional‚Äô in its marketing material or shares a family origin with those listed on the sidebar of r/functionalprogramming.

    For the sake of this article, I am willing to tolerate the imprecision of ‚ÄòFearless Tinkering is Functional‚Äô over something that might better match like ‚Äòexpression-oriented‚Äô, ‚Äòdenotative‚Äô, ‚Äòalgebraic‚Äô, or 'structural' (definitional claims are unfalsifiable anyways). I am also willing, when a claim reflects my own opinions, to forgo small nuances (or bury them in footnotes) when speaking to unacquainted audiences. My goals with this specific article are more about connecting valuable ideas through familiar phrasing to a wider audience than advancing a discussion for those already equipped with understanding.

    I do think there are more general problems with various commonly-used terms by functional programmers, and that particular statements often lead to poor intuitions and mismatched discussions. I hope to publish more on this topic soon.
[^8]:
    No one needs to learn category theory to become a [great functional programmer](http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/)! Sure, some people have brought great ideas from category theory and other mathematical fields back to the realm of programming. But math gets invented to incorporate great ideas originating from programming (and everywhere else) as well. The [streelight effect](https://en.wikipedia.org/wiki/Streetlight_effect) goes both ways! Programmers should treat math as a tool that serves to give us understanding, rather than a tool we serve to give our understanding.
[^9]:
    Many more words will be dedicated to this topic in an upcoming article titled "Frontload. Permit. Retrofit."
[^10]:
    There are too many examples for exhaustive and in-depth coverage. For example, I don't cover "fearless concurrency" in Erlang and Elixir. If you have follow-up writings describing other examples, [I'd love to link them below](https://github.com/hkailahi/heneli.dev/issues):

    - TBD
[^11]: [So fearless](https://github.com/NorfairKing/haskell-WAT)...

    ```haskell
    Œª> length ('a','b')
    1
    Œª> maximum (2,1)
    1
    Œª> minimum (1,2)
    2
    Œª> sum (2,1)
    1
    Œª> and (False, True)
    True
    Œª> or (True, False)
    False
    ```
[^12]:
    The original quote differentiated Haskell's support for "lightweight threads that use non-blocking I/O" from the JVM. Java originally had green threads before before deprecating them in favor of using OS threads. As of 2022, lightweight threads have been re-introduced via [Project Loom](https://blogs.oracle.com/javamagazine/post/going-inside-javas-project-loom-and-virtual-threads) with [Java 19](https://www.oracle.com/news/announcement/oracle-releases-java-19-2022-09-20/).
[^13]:
    While I believe Nix is worth exploring for most developers, it's important that interested parties know what they're signing up for. Learning Nix is a significant undertaking. The explicit, build-from-source model means that package authors are forced to confront essential complexity up front rather than accruing tech debt that can be paid later. Roadblocks commonly manifest from the bizarre assumptions made by various software about their host environment and toolchain. The cruel reality is that many packaging tasks with Nix are actually just sophisticated ways of glueing [bash scripts](https://nixos.org/manual/nixpkgs/stable/#chap-stdenv) together. Fortunately for end-users, many pre-defined packages exist and are available for modification or cached download. In fact, the [Nix ecosystem's primary package repository](https://search.nixos.org/packages) contains the largest number of "fresh packages" [by a wide margin](https://repology.org/repositories/graphs). For everything else, end-users can use provided ["fetchers"](https://nixos.org/manual/nixpkgs/stable/#chap-pkgs-fetchers) to shorcut the build-from-source model while still benefitting from pinned dependencies. These fetchers allow callers to retrieve artifacts from various sources and verify their contents against a hash. Similar to `git`, Nix's underlying model is much simpler to grasp than the current interfaces for interacting with it. Ongoing contributions by generous individuals are being made towards reflecting this simplicity and polishing end-user interfaces.

    Fortunately, there's been a surge of beginner-friendly tools allow newcomers to get the benefits of Nix immediately. Some examples include [`flox`](https://floxdev.com/blog/homebrew), [`devenv`](https://devenv.sh/), [`fleek`](https://getfleek.dev/), and [`devbox`](https://www.jetpack.io/devbox/). These services build on top of Nix to provide access to things like package management, container development, and package/environment distribution.

    To get started with Nix proper, I recommend following the [Zero to Nix](https://zero-to-nix.com/) Quick Start guide. From there, I recommend checking out [nix.dev](https://nix.dev/), the [Official NixOS learning page](https://nixos.org/learn.html), and the follow-up resources recommended at the end of the [Zero to Nix](https://zero-to-nix.com/start/learn-more) Quick Start guide. For video learners, Brian McKenna's [RootConf 2019 talk](https://youtu.be/RtqWE5lgaCg) and Burke Libbey's [Nix: What Even is it Though](https://youtu.be/6iVXaqUfHi4) are great introductory overviews of Nix and its ideas.

    For intermediate audiences, check out the upcoming [NixOS in Production](https://leanpub.com/nixos-in-production) book.

    Below are writings that I've particularly enjoyed:

    - [Erase your darlings](https://grahamc.com/blog/erase-your-darlings/)
    - [Paranoid NixOS Setup](https://xeiaso.net/blog/paranoid-nixos-2021-07-18) and [Paranoid NixOS on AWS](https://xeiaso.net/blog/paranoid-nixos-aws-2021-08-11)
    - [Tidying up your $HOME with Nix](https://juliu.is/tidying-your-home-with-nix/)
    - [Declarative management of dotfiles with Nix and Home Manager](https://www.bekk.christmas/post/2021/16/dotfiles-with-nix-and-home-manager)
    - [Managing Firefox on macOS with Nix](https://cmacr.ae/post/2020-05-09-managing-firefox-on-macos-with-nix/)
    - The original thesis, [The Purely Functional Software Deployment Model](https://edolstra.github.io/pubs/phd-thesis.pdf), and a modern review titled [The Nix Thesis](https://jonathanlorimer.dev/posts/nix-thesis.html)
    - The NixOS paper, [NixOS: A Purely Functional Linux Distribution](https://edolstra.github.io/pubs/nixos-jfp-final.pdf)
[^14]:
    For video learners, Philipp Hagenlocher's [Haskell for Imperative Programmers](https://www.youtube.com/playlist?list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV) playlist is a phenomenal introductory exposure.

    If, like me, you like 1000+ page tutorials with ample hand-holding, you could learn with [Haskell from First Principles](https://haskellbook.com/). Otherwise, the upcoming [Effective Haskell](https://pragprog.com/titles/rshaskell/effective-haskell/) book seems, from my brief skim, like a promising early resource. Additionally, helpful online references like [Typeclasses](https://typeclasses.com/) and [Kowainik‚Äôs blog](https://kowainik.github.io/posts) can be very beginner-friendly. [fp-course](https://github.com/system-f/fp-course) and Brian McKenna's [video walkthrough](https://www.youtube.com/playlist?list=PLly9WMAVMrayYo2c-1E_rIRwBXG_FbLBW) is a great hands-on exercise that‚Äôs perfect for beginners struggling to grapple with fundamental abstractions. Finally, [What I Wish I Knew When Learning Haskell](https://github.com/sdiehl/wiwinwlh) can serve as a solid, free reference for checking your understanding of various topics.

    For intermediate audiences, I can strongly recommend [Production Haskell](https://www.amazon.com/Production-Haskell-Succeeding-Industry/dp/B0BTNVFR2N), [Thinking with Types](https://thinkingwithtypes.com/), and the _Concurrent_ section of the classic [Parallel and Concurrent Programming in Haskell](https://www.amazon.com/Parallel-Concurrent-Programming-Haskell-Multithreaded/dp/1449335942). Additionally, promising works on the horizon like [The Haskell Optimization Handbook](https://github.com/input-output-hk/hs-opt-handbook.github.io) and some unannounced efforts make now a great time to get in.
